<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端多角色权限页面（同浏览器同时登录）权限互串</title>
      <link href="/loginissure/"/>
      <url>/loginissure/</url>
      
        <content type="html"><![CDATA[<h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>由于不同角色权限不同，显示的界面也就不同（功能与主题等），同浏览器同时登录不同角色会出现角色互串的问题，以下分析与解决均为同浏览器所在环境</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="1、登录逻辑"><a href="#1、登录逻辑" class="headerlink" title="1、登录逻辑"></a>1、登录逻辑</h5><ul><li>用户输入登录信息，点击登录向服务端发起请求，服务端根据前端发送的登录信息返回成功或失败，成功返回<code>token</code>字段与用户角色，<code>token</code>字段为加密字段，表明用户身份信息，并携带过期时间，供前端后续请求接口调用，前端通过判断用户角色展示相应角色权限与主题</li><li>前端拿到<code>token</code>后存储到本地<code>Storage</code>，并在请求拦截中获取并判断本地<code>token</code>存不存在，存在即证明有身份信息，可以访问用户接口，不存在即证明用户未登录或已失效删除，重新导航到登录页<h5 id="2、多角色登录"><a href="#2、多角色登录" class="headerlink" title="2、多角色登录"></a>2、多角色登录</h5></li><li>首先登录账户A，A账户的<code>tokenA</code>与<code>角色A</code>就会存储到<code>Storage</code>，A账户有权限<code>featureA1</code>、<code>featureA2</code>，主题为<code>featureRed</code>，在App.vue监听，这时重新打开一个<code>页签2</code>，输入同样路由地址，会检测到A账户<code>tokenA</code>存在并跳转到A账户对应的路由，同原有<code>页签1</code>显示相同，如果这个时候退出<code>页签2</code>账户，清除<code>tokenA</code>、<code>角色A</code>，<code>页签1</code>就会存在以下两种情况：<ul><li>1、<code>页签1</code>浏览器刷新：路由会监听到<code>token</code>不存在跳转到指定路由（登录页面）并给出相关提示</li><li>2、<code>页签1</code>浏览器不刷新，直接点击A账户权限路由：会请求服务器数据，请求拦截会判断有没有<code>token</code>，没有会导航到指定路由（登录页面）并给出相关提示</li></ul></li><li>如果退出<code>页签2</code>账户，清除<code>tokenA</code>、<code>角色A</code>，并且直接在<code>页签2</code>登录账户B，这时候本地<code>Storage</code>就会存储<code>tokenB</code>与<code>角色B</code>，<code>页签2</code>的权限为<code>featureB1</code>、<code>featureB2</code>，主题为<code>featureBlue</code>，这个时候的<code>页签1</code>就会存在以下两种情况：<ul><li>1、<code>页签1</code>浏览器刷新：这时组件全面刷新，功能权限组件重新渲染，并重新获取新的<code>tokenB</code>，重新设置功能权限为<code>featureB1</code>、<code>featureB2</code>，App.vue重新获取本地用户角色，更改主题为<code>featureBlue</code>，从而实现了角色的跳转</li><li>2、<code>页签1</code>浏览器不刷新，直接点击A账户权限路由：由于<code>Storage</code>现在存储的是账户B的信息，账户A界面就会携带账户B的身份去请求接口，这是很大的错误。所以必须还要有路由权限设置，不同角色设置不同<code>meta</code>属性，如果A账户请求B账户路由，<code>meta</code>会不一样，这样设置导航到配置好的404页面，这显然不是我们想要的结果<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5>我们在路由拦截判断<code>meta</code>角色属性，如果和获取到的<code>Storage</code>里的角色不匹配，会导航到404页面，但是我们导航到404页面的时候可以携带获取到的当前登录用户角色B参数过去，我们重新设计404页面，通过参数信息提示用户已经登录用户B，点击按钮跳转到用户B的主页，主页勾子函数调用，改变功能界面为<code>featureB1</code>、<code>featureB2</code>，主题为<code>featureBlue</code><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5>我们可以通过判断用户身份信息的更新来强制跳转页面：比如观察<code>token</code>，当当前用户的<code>tokenB</code>与之前存储的<code>tokenA</code>不同的时候，强制刷新页面，让路由回到<code>&#39;/&#39;</code>，导航到首页，具体如下：</li><li>用户登录成功，存储相应<code>token</code>信息到本地</li><li>在<code>vuex</code>中加<code>token</code>字段用以存储用户信息</li><li>在App.vue中观察<code>vuex</code>中的<code>token</code>，如果不存在，获取本地<code>Storage</code>的值并赋值给<code>vuex</code>的<code>token</code>，如果存在，拿<code>vuex</code>中的<code>token</code>和<code>Storage</code>中的<code>token</code>比较，如果相同什么都不用做，如果不相同，说明新的登录存在了，获取当前路径信息并去除掉路由部分，赋值给<code>window.location.href</code>，这样就实现了强制刷新跳转到<code>&#39;/&#39;</code></li></ul></li></ul><p>实际情况可能会遇到各种各样的问题，通过思考可能会有很多种方法，如果大家有什么好的方法或者指正，欢迎交流</p>]]></content>
      
      
      <categories>
          
          <category> 功能类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录互串 </tag>
            
            <tag> 浏览器登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue+node(express)+mysql部署阿里云服务器</title>
      <link href="/deploy/"/>
      <url>/deploy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="一、购买服务器"><a href="#一、购买服务器" class="headerlink" title="一、购买服务器"></a>一、购买服务器</h2><ul><li>1 、进入阿里云官网，选择服务器ECS，我买的是学生的，当然你要是学生，可以通过身份购买学生专用优惠服务器，9.5一个月<br><img src="https://img-blog.csdnimg.cn/20190621161723782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>2、接下来会有个密码设置，这个密码会从始至终会用到哦<br><img src="https://img-blog.csdnimg.cn/20190621161941708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>3、购买成功后，实例就创建成功了，也就会有自己的服务器了<br><img src="https://img-blog.csdnimg.cn/20190621162535950.png" alt="在这里插入图片描述"></li><li>4、在控制台中可以查看自己的实例，里面会有你所买的服务器的ip地址，且显示运行中，到此，就可以开始部署准备工作了</li></ul><h2 id="二、下载安装putty和Xftp"><a href="#二、下载安装putty和Xftp" class="headerlink" title="二、下载安装putty和Xftp"></a>二、下载安装putty和Xftp</h2><p><strong><code>注意：此教程针对windows系统，mac可根据如下参考本教程</code></strong></p><ul><li><strong>连接服务器方面：</strong><code>windows</code> 通过 <code>putty</code> ，<code>mac</code> 中 不用 <code>putty</code>，命令行直接通过<code>ssh root@xxx.xx.xxx.xx -p 22</code>连接服务器，因为后面都是在 <code>linux</code> 中执行命令，所以命令同 <code>windows</code> 相同</li><li><strong>传输文件方面：</strong><code>mac</code> 下下载 <code>FileZilla</code>，<code>FileZilla</code> 同 <code>Xftp</code> ，设置好 ip 和端口连接即可，使用方式基本相同</li></ul><hr><p><strong><code>putty</code>和<code>Xftp</code>可在网上自行下载安装</strong></p><h3 id="putty连接服务器"><a href="#putty连接服务器" class="headerlink" title="putty连接服务器"></a>putty连接服务器</h3><p>1、打开putty<br><img src="https://img-blog.csdnimg.cn/2019062116323943.png" alt="在这里插入图片描述"><br>2、根据图中设置ip<br><img src="https://img-blog.csdnimg.cn/20190621163620697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、出现下面界面，设置登录名，为root，登录密码为注册服务时设置的密码（输入密码不会出现字符，放心输入完了按回车就是了）<br><img src="https://img-blog.csdnimg.cn/20190621163855163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、登录成功后，就进入到<code>Linux</code>系统了<br><img src="https://img-blog.csdnimg.cn/2019062116411241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>1、先把yum更新到最新版本</p><pre><code class="Shell">yum -y update</code></pre><p>2、我们将使用最新源代码构建Node.js，要进行软件的安装，需要一组用来编译源代码的开发工具</p><pre><code class="Shell">yum -y groupinstall &quot;Development Tools&quot;</code></pre><p>3、进入/usr/src文件夹，这个文件夹通常用来存放软件源代码</p><pre><code class="Shell">cd /usr/src</code></pre><p>4、从 <code>Node.js</code>的站点 中获取压缩档源代码, 我选择的版本为<code>v10.13.0</code></p><pre><code class="Shell">wget http://nodejs.org/dist/v10.13.0/node-v10.13.0.tar.gz </code></pre><p>5、解压文件，并进入文件夹</p><pre><code class="Shell">tar zxf node-v10.13.0.tar.gzcd node-v6.9.1</code></pre><p>6、设置全局环境变量，为了能够在全局使用node命令</p><pre><code class="Shell">ln -s /usr/src/node-v10.13.0/bin/node /usr/local/bin/nodeln -s /usr/src/node-v10.13.0/bin/npm /usr/local/bin/npm</code></pre><p>7、查看是否成功设置</p><pre><code class="Shell">node -vnpm -v</code></pre><p>8、 安装pm2<br><strong><code>pm2</code>用于启动程序并在需要时重启非常有用的模块，可以随时查看服务的运行状态</strong></p><pre><code class="Shell">npm -g install pm2 </code></pre><p>9、设置全局变量</p><pre><code class="Shell">ln -s /usr/src/node-v10.13.0/bin/pm2 /usr/local/bin/</code></pre><p>接下来就可以用<code>pm2</code>命令了</p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>1、寻找社区源安装到<code>tmp</code>中</p><pre><code class="Shell">cd /tmpwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm  rpm -ivh mysql-community-release-el7-5.noarch.rpm  </code></pre><p>2、通过yum安装</p><pre><code class="Shell">yum install mysql mysql-server mysql-devel -y</code></pre><p><img src="https://img-blog.csdnimg.cn/20190621181031112.png" alt="在这里插入图片描述"><br>3、启动mysql</p><pre><code class="Shell">systemctl start mysql.service</code></pre><p>4、设置用户和密码<br><code>通过yum安装的是没有用户名和密码的，所以得设置</code></p><pre><code class="Shell">mysqladmin -u root password admin</code></pre><p>用户名为<code>root</code>，密码为<code>admin</code><br>5、设置好后就可以登录了</p><pre><code class="Shell">mysql -uroot -padmin</code></pre><p>查看数据库</p><pre><code class="Shell">show databases;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190621181945585.png" alt="在这里插入图片描述"><br>自此，数据库配置完毕</p><h3 id="Xftp上传代码"><a href="#Xftp上传代码" class="headerlink" title="Xftp上传代码"></a>Xftp上传代码</h3><p>1、打开下载的<code>Xftp</code><br><img src="https://img-blog.csdnimg.cn/20190621182402956.png" alt="在这里插入图片描述"><br>2、点击新建<br><img src="https://img-blog.csdnimg.cn/20190621182637762.png" alt="在这里插入图片描述"><br>出现<br><img src="https://img-blog.csdnimg.cn/20190621182723796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>名称自己取一个项目名称。主机，填写阿里云服务器的公网<code>IP</code>，协议选择<code>SFTP</code>，端口使用<code>22</code>，用户名<code>root</code>，密码为购买阿里云的时候要你记住的密码。最后点击确定。</strong><br>3、双击下面图标，进入 <code>root</code>文件夹<br><img src="https://img-blog.csdnimg.cn/20190621182945604.png" alt="在这里插入图片描述"><br>如图：左边为本地电脑，右边为服务端文件夹<br><img src="https://img-blog.csdnimg.cn/201906211832036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们把自己的<code>node项目</code>通过右键传输传进<code>home/自定义文件夹/</code>里,当然数据库文件也要一同传上去以便初始化<br><img src="https://img-blog.csdnimg.cn/20190621183423798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、<strong><code>服务代码传到服务器上后要进入服务器 node 根目录通过 putty 进行 npm install 安装相关依赖</code></strong></p><h3 id="启动node应用"><a href="#启动node应用" class="headerlink" title="启动node应用"></a>启动node应用</h3><p><strong>上传完代码后，再回到putty，进入项目目录，利用pm2启动应用</strong></p><pre><code class="Shell">cd /home/jqqpm2 start server.js --name test</code></pre><p>后面<code>--name</code>可以不写，重命名的意思<br>当出现下面表格说明成功启动了<br><img src="https://img-blog.csdnimg.cn/20190621184108984.png" alt="在这里插入图片描述"></p><ul><li>通过<code>pm2 list</code>检视运行中的应用</li><li>通过<code>pm2 stop test</code>停止应用</li><li>通过<code>pm2 delete test</code>删除应用</li><li>通过<code>pm2 log app</code>查看应用日志</li></ul><p>到这里node启动就完成了</p><h3 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h3><p>为避免大小写识别失败，对大小写进行配置<br>1、打开配置文件</p><pre><code class="Shell">vi /etc/my.cnf</code></pre><p>按 <code>i</code> 键进行编辑，如图在<code>[mysqld]</code>后添加<code>lower_case_table_names=1</code>，按 <code>esc</code> 键，再输入 <code>:wq</code> 保存退出<br><img src="https://img-blog.csdnimg.cn/20190621185154866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、重启<code>mysql</code></p><pre><code class="Shell">systemctl restart mysqld.service</code></pre><p>3、连接数据库</p><pre><code class="Shell">mysql -uroot -padmin</code></pre><p>4、创建test数据库</p><pre><code class="Shell">CREATE DATABASE test DEFAULT CHARACTER SET utf8;</code></pre><p>通过<code>show databases;</code>查看数据库已经存在了<br>4、导入数据</p><ul><li><p>接着上个步骤，先用组合键 ctrl+c退出mysql控制台，然后在linux的环境下输入如下命令导入数据</p><pre><code class="Shell">mysql -u root -padmin --default-character-set=utf8 test &lt; /home/jqq/web.sql</code></pre><p>5、验证数据</p><pre><code class="Shell">mysql -uroot -padminuse test;show tables;select count(*) from product;</code></pre><p>6、配置登录权限</p><pre><code class="Shell">grant all privileges on `test`.* to &#39;root&#39;@&#39;%&#39; identified by &#39;admin&#39; with grant option;mysql&gt; FLUSH PRIVILEGES;</code></pre><p><code>test为数据库，root为用户，admin为密码，下面命令为让配置生效</code><br>这样数据就设置完成可以启动了</p><h2 id="三、安装配置tomcat"><a href="#三、安装配置tomcat" class="headerlink" title="三、安装配置tomcat"></a>三、安装配置tomcat</h2><p>1、安装<br><code>yum</code>上没有<code>tomcat</code>的源，可以到官网去下载最新的通过<code>Xftp</code>传到<code>tmp</code>里，并使用如下方式下载解压，通过<code>mv</code>命令移动文件夹</p><pre><code class="Shell">cd /tmpwget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.92/bin/apache-tomcat-7.0.92.tar.gztar xzf apache-tomcat-7.0.92.tar.gzmv apache-tomcat-7.0.92 /usr/local/tomcat7</code></pre><p>2、启动tomcat</p><pre><code class="Shell">/usr/local/tomcat7/bin/startup.sh</code></pre><p><img src="https://img-blog.csdnimg.cn/20190621192706921.png" alt="在这里插入图片描述"><br>3、验证</p><pre><code class="Shell">netstat -anp|grep 8080</code></pre><p><img src="https://img-blog.csdnimg.cn/20190621192822610.png" alt="在这里插入图片描述"><br>4、安全组开放端口<br><img src="https://img-blog.csdnimg.cn/20190621192930313.png" alt="在这里插入图片描述"><br>5、再vue的router中如下配置，完了打包上传<br><img src="https://img-blog.csdnimg.cn/20190621193405506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6、通过Xftp把vue打包好的文件传送到tomcat中，如图：我在webapps中新建了个文件夹，这样将来访问路径就会多出二级路径jqqzz，当然大家都可以放到根目录不必创建二级路径<br><img src="https://img-blog.csdnimg.cn/20190621193109445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7、在<code>jqqzz</code>项目中新建文件夹<code>WEB-INF</code>，再里面新建文件<code>web.xml</code><br>编辑文件，把如下插入到文件中，处理<code>404</code>返回<code>index.html</code>页面,并且处理<code>history</code>模式</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee                   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;version=&quot;3.0&quot;metadata-complete=&quot;true&quot;&gt;&lt;display-name&gt;webapp&lt;/display-name&gt;&lt;description&gt;  webapp&lt;/description&gt;&lt;error-page&gt;  &lt;error-code&gt;404&lt;/error-code&gt;  &lt;location&gt;/index.html&lt;/location&gt;  &lt;/error-page&gt;  &lt;/web-app&gt;</code></pre><p>这样访问 <code>ip:8080/jqqzz</code>就可以进到自己的项目啦</p></li></ul><p><strong><code>注意：在某些时候，一些命令操作文件的时候会没有权限导致失败，这时使用一下命令给予文件或文件夹权限，777为所有用户拥有最高权限，R表示允许其目录下的子目录的文件及文件夹</code></strong></p><pre><code class="Shell">chmod 777 文件夹或文件名chmod 777 *.文件类型</code></pre><p>这样所有工作就都大功告成了</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> node </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基于vue企业微信JS-SDK语音识别功能开发（同公众号）</title>
      <link href="/js-sdk/"/>
      <url>/js-sdk/</url>
      
        <content type="html"><![CDATA[<p>@<a href="前端基于vue企业微信JS-SDK语音识别功能开发（同公众号）">TOC</a></p><h1 id="微信JS-SDK"><a href="#微信JS-SDK" class="headerlink" title="微信JS-SDK"></a>微信JS-SDK</h1><p>前端需要实现一个功能，如录音，拍照，分享，地理位置等，前端想要实现这些功能的调用，必须要通过调用JS-SDK的方式来实现，那么如何使用呢，本文进行简单的介绍</p><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><p>因为是第一次开发，看了很多文档，包括官方文档，看了很多遍，仍然是一头雾水，那些东西该前端配，哪些东西该后端做，没有一点概念。经过了一番与后端的尝试与合作，终于调用成功！<br>企业微信里有个应用与小程序，里面的自建应用开发同公众号开发，<strong>后端设置略微有些不同</strong><br><img src="https://img-blog.csdn.net/20180927113024399?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这个是企业微信里的目录"><br><strong>后端</strong>：根据企业微信里我的企业选项最下面的企业id和应用与小程序里的自建应用的Secret获取token，并计算签名等一系列操作，具体官方文档网上都很详细，这里就不多说；<br><strong>配置</strong><br>需要在企业微信的自建程序里设置域名：此域名为前端写代码的外网网页域名，也就是最后呈现的网页域名（前端写完代码给后端，后端根据项目地址<code>我的是gitLab</code>配置外网域名），第一次配置需要启动，所以要和后端配合好，启动时有一个txt文件，前端需要打包给后端，后端配置到根目录并确保可以访问到txt文件<br><img src="https://img-blog.csdn.net/20180927113801817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIwNDY5OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><code>说明：</code>此域名的配置是必要的，只有配置此域名才可以使用此域名调用JS-SDK，可以使用<strong>微信开发者工具</strong>的公众号开发选项进行在线调试域名，<code>注意：</code>只可以调试你打包到线上的外网ip</p><h2 id="前端代码撰写"><a href="#前端代码撰写" class="headerlink" title="前端代码撰写"></a>前端代码撰写</h2><p>安装并在组建里引入wx</p><pre><code>import wx from &#39;weixin-js-sdk&#39;;const _this = wx;</code></pre><p>要想在一个组件使用在当前组件引入就行，引入完成就是使用，在页面调用接口之前必须完成注册等逻辑，因为录音功能是手动触发执行，所以在vue中可以写个函数在mounted钩子函数中执行完成注册，代码如下：</p><pre><code>methods: {      getConfig() {        const self=this;        const data=self.qs.stringify({url: location.href.split(&#39;#&#39;)[0]});//需要传的地址为#前面的地址        self.axios({          method: &#39;post&#39;,          url: &#39;&#39;,//获取签名等信息的地址          headers: {&#39;Content-Type&#39;: &#39;application/json&#39;},          data:data  //向服务端提供授权url参数，并且不需要#后面的部分        }).then((res) =&gt; {           let list = res.data.data;              _this.config({            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。            appId: list.appId, // 必填，公众号的唯一标识            timestamp: list.timestamp, // 必填，生成签名的时间戳            nonceStr: list.noncestr, // 必填，生成签名的随机串            signature: list.signature, // 必填，签名            jsApiList: [              &#39;startRecord&#39;, //开始录音接口              &#39;stopRecord&#39;,// 停止录音接口              &#39;playVoice&#39;, //播放语音接口              &#39;pauseVoice&#39;,//暂停播放接口              &#39;stopVoice&#39;, //停止播放接口              &#39;uploadVoice&#39;,//上传语音接口              &#39;downloadVoice&#39;, //下载语音接口              &#39;onVoicePlayEnd&#39;, // 监听语音播放完毕api              &#39;translateVoice&#39;            ] // 必填，需要使用的JS接口列表          });          _this.ready(() =&gt; {            // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个            // 客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调            // 用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。          })          _this.error((res) =&gt; {            // 这个地方的好处就是wx.config配置错误，会弹出窗口哪里错误，然后根据微信文档查询即可。          })        }).catch((error) =&gt; {          // error        })      },      // 开始录音      start(e) {        let that = this;        that.stop();        that.time = 0;        if(!localStorage.rainAllowRecord || localStorage.rainAllowRecord !== &#39;true&#39;){          _this.startRecord({            success: function () {                   that.timer = setInterval(() =&gt; {                that.time++              }, 1000)              that.vicoeEnd()            },            fail: function () {              // 开始录音失败            },            cancel: function () {              // 用户拒绝授权录音            }          })        }      },      // 停止录音      stop() {        let that = this          _this.stopRecord({          success: function (res) {            if(that.time&lt;0.5){              return            }            // 暂停成功            clearInterval(that.timer)            that.localId = res.localId          },          fail: function (error) {            // 停止失败          }        })      },      //取消录音判断      isCancel(e) {          this.cancel()      },      // 取消录音      cancel() {        _this.stopRecord({          success: (res) =&gt; {            // 取消录音成功          },          fail:function (error) {            // 取消录音失败          }        })      },      // 60秒监听      vicoeEnd() {        let that = this        _this.onVoiceRecordEnd({          // 录音时间超过一分钟没有停止的时候会执行 complete 回调          complete: function (res) {            // 60秒停止录音            that.localId = res.localId            clearInterval(that.timer);          }        })      },      // 合并      merge() {        let that = this        this.axios({          method: &#39;post&#39;,          url: &#39;&#39;,          headers: {&#39;Content-Type&#39;: &#39;application/json&#39;},          data: {url: location.href.split(&#39;#&#39;)[0]}        }).then((ser) =&gt; {            that.$refs.allRecord.src = ser.data        }).catch((error) =&gt; {          // error        })      },      // 结束录音并识别语音      translate () {        const that = this;        _this.stopRecord({          success: function (res) {            // 翻译前停止录音            that.localId = res.localId;            _this.translateVoice({              localId: that.localId,              complete: function (res) {                // 调用翻译完成时              }            });          },          fail: function (res) {            // 调用停止失败          }        });      },      // 上传语音      upVoice() {        let that = this        _this.uploadVoice({          localId: that.localId, // 需要上传的音频的本地ID，由stopRecord接口获得          isShowProgressTips: 1, // 默认为1，显示进度提示          success: function (res) {            var apiUrl = window.location.href            // 上传成功            that.serverId = res.serverId // 返回音频的服务器端ID            that.axios({              method: &#39;post&#39;,              url: &#39;http://my.service.com/index.php/opcode/6002&#39;,              headers: {&#39;Content-Type&#39;: &#39;application/json&#39;},              data: {                serverId: res.serverId,                url: location.href.split(&#39;#&#39;)[0]              }            }).then((data) =&gt; {                that.$refs.player.src = data.data            }).catch((error) =&gt; {              // error            })          }        })      }      // 下载语音      // downVoice () {      //   let that = this      //   _this.downloadVoice({      //     serverId: that.serverId, // 需要下载的音频的服务器端ID，由uploadVoice接口获得      //     isShowProgressTips: 1, // 默认为1，显示进度提示      //     success: function (res) {      //       // 下载成功      //       that.downLoadId = res.localId // 返回音频的本地ID      //     }      //   })      // },      // 模拟上传语音      // fake () {      //   var apiUrl = window.location.href      //   this.axios({      //     method: &#39;post&#39;,      //     url: &#39;api&#39;,      //     headers: {&#39;Content-Type&#39;: &#39;application/json&#39;},      //     data: {      //       serverId: &#39;&#39;,      //       url: apiUrl      //     }      //   }).then((res) =&gt; {      //       this.$refs.player.src = res.data      //     }).catch((error) =&gt; {      //       // error      //     })      // }    },</code></pre><p><strong>这里样式代码根据需要进行编写就行，哪个按钮需要调用录音开始，哪个按钮调用录音结束，哪个需要翻译，需要用到哪个功能，直接调用methods里面的对应方法即可，（如果调用其它JS-SDK，原理等同，注册时给jsApiList数组添加你需要的功能字段<code>微信公众号API文档可查</code>就可以引用了）， 需要对应方法执行成功后做的事情在对应方法里写就ok啦</strong></p><p>是不是很简单呢，代码撰写完毕就是打包代码提交代码了，后台更新代码到线上，就可以看到效果了。<code>注意：</code>由于微信开发者工具是模拟调试，所以只能有一条模拟的录音结果返回，真正的语音及翻译结果还得发送网址到微信里打开查看</p><p>好了，微信JS-SDK接口调用就介绍到这里了，新手初写，希望能帮助到大家，也请大家多多指导</p>]]></content>
      
      
      <categories>
          
          <category> 手机端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
            <tag> vue </tag>
            
            <tag> JS-SDK </tag>
            
            <tag> 语音识别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
